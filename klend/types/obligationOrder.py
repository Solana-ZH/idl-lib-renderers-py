'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from construct import Container
from dataclasses import dataclass

class ObligationOrderJSON(typing.TypedDict):
    conditionThresholdSf: int
    opportunityParameterSf: int
    minExecutionBonusBps: int
    maxExecutionBonusBps: int
    conditionType: int
    opportunityType: int
    padding1: list[int]
    padding2: list[int]

@dataclass
class ObligationOrder:
    layout: typing.ClassVar = borsh.CStruct(
        "conditionThresholdSf" /borsh.U128,
        "opportunityParameterSf" /borsh.U128,
        "minExecutionBonusBps" /borsh.U16,
        "maxExecutionBonusBps" /borsh.U16,
        "conditionType" /borsh.U8,
        "opportunityType" /borsh.U8,
        "padding1" /borsh.U8[10],
        "padding2" /borsh.U128[5],
        )
    #fields
    conditionThresholdSf: int
    opportunityParameterSf: int
    minExecutionBonusBps: int
    maxExecutionBonusBps: int
    conditionType: int
    opportunityType: int
    padding1: list[int]
    padding2: list[int]
    
    @classmethod
    def from_decoded(cls, obj: Container) -> "ObligationOrder":
        return cls(
        conditionThresholdSf=obj["conditionThresholdSf"],
        opportunityParameterSf=obj["opportunityParameterSf"],
        minExecutionBonusBps=obj["minExecutionBonusBps"],
        maxExecutionBonusBps=obj["maxExecutionBonusBps"],
        conditionType=obj["conditionType"],
        opportunityType=obj["opportunityType"],
        padding1=obj["padding1"],
        padding2=obj["padding2"],
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
                "conditionThresholdSf": self.conditionThresholdSf,
                "opportunityParameterSf": self.opportunityParameterSf,
                "minExecutionBonusBps": self.minExecutionBonusBps,
                "maxExecutionBonusBps": self.maxExecutionBonusBps,
                "conditionType": self.conditionType,
                "opportunityType": self.opportunityType,
                "padding1": self.padding1,
                "padding2": self.padding2,
                }

    def to_json(self) -> ObligationOrderJSON:
        return {
                "conditionThresholdSf": self.conditionThresholdSf,
                "opportunityParameterSf": self.opportunityParameterSf,
                "minExecutionBonusBps": self.minExecutionBonusBps,
                "maxExecutionBonusBps": self.maxExecutionBonusBps,
                "conditionType": self.conditionType,
                "opportunityType": self.opportunityType,
                "padding1": self.padding1,
                "padding2": self.padding2,
                }

    @classmethod
    def from_json(cls, obj: ObligationOrderJSON) -> "ObligationOrder":
        return cls(
                conditionThresholdSf=obj["conditionThresholdSf"],
                opportunityParameterSf=obj["opportunityParameterSf"],
                minExecutionBonusBps=obj["minExecutionBonusBps"],
                maxExecutionBonusBps=obj["maxExecutionBonusBps"],
                conditionType=obj["conditionType"],
                opportunityType=obj["opportunityType"],
                padding1=obj["padding1"],
                padding2=obj["padding2"],
        )






